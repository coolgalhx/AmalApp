// Service Worker for Offline Functionality
const CACHE_NAME = 'hope-triage-v1';
const OFFLINE_CACHE = 'hope-offline-v1';

// Resources to cache for offline functionality
const CACHE_URLS = [
  '/',
  '/index.html',
  '/manifest.json',
  // Add key CSS and JS files that would be generated by Vite
  // These will be dynamically cached when first accessed
];

// Medical data that should be available offline
const OFFLINE_MEDICAL_DATA = {
  primaryCauses: ['injury', 'burn', 'trauma', 'infection'],
  symptoms: {
    injury: ['pain', 'swelling', 'bleeding', 'bruising', 'difficulty moving'],
    burn: ['pain', 'redness', 'blisters', 'peeling skin', 'fever'],
    trauma: ['headache', 'dizziness', 'confusion', 'nausea', 'loss of consciousness'],
    infection: ['fever', 'redness', 'swelling', 'pus', 'red streaks']
  },
  recommendations: {
    low: {
      title: 'Low Priority',
      description: 'Monitor symptoms and use home care methods',
      actions: ['Rest', 'Over-the-counter pain relief', 'Monitor for changes', 'Consult doctor if worsens']
    },
    medium: {
      title: 'Medium Priority', 
      description: 'Consider medical consultation within 24-48 hours',
      actions: ['Apply first aid', 'Monitor symptoms closely', 'Schedule doctor visit', 'Call if symptoms worsen']
    },
    high: {
      title: 'High Priority',
      description: 'Seek medical attention promptly',
      actions: ['Seek urgent care', 'Apply immediate first aid', 'Call doctor immediately', 'Go to emergency room if severe']
    },
    emergency: {
      title: 'Emergency',
      description: 'Call emergency services immediately',
      actions: ['Call 911 now', 'Apply emergency first aid', 'Do not wait', 'Get to hospital immediately']
    }
  }
};

// Install event - cache resources
self.addEventListener('install', (event) => {
  console.log('Service Worker installing...');
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => {
        console.log('Caching app shell');
        return cache.addAll(CACHE_URLS);
      })
      .then(() => {
        // Cache offline medical data
        return caches.open(OFFLINE_CACHE);
      })
      .then((cache) => {
        console.log('Caching offline medical data');
        return cache.put('/api/offline-data', new Response(JSON.stringify(OFFLINE_MEDICAL_DATA), {
          headers: { 'Content-Type': 'application/json' }
        }));
      })
      .then(() => {
        console.log('Service Worker installed successfully');
        return self.skipWaiting();
      })
  );
});

// Activate event - clean up old caches
self.addEventListener('activate', (event) => {
  console.log('Service Worker activating...');
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (cacheName !== CACHE_NAME && cacheName !== OFFLINE_CACHE) {
            console.log('Deleting old cache:', cacheName);
            return caches.delete(cacheName);
          }
        })
      );
    }).then(() => {
      console.log('Service Worker activated');
      return self.clients.claim();
    })
  );
});

// Fetch event - serve from cache when offline
self.addEventListener('fetch', (event) => {
  // Handle offline data API requests
  if (event.request.url.includes('/api/offline-data')) {
    event.respondWith(
      caches.match('/api/offline-data')
        .then((response) => {
          return response || new Response(JSON.stringify(OFFLINE_MEDICAL_DATA), {
            headers: { 'Content-Type': 'application/json' }
          });
        })
    );
    return;
  }

  // Handle assessment storage
  if (event.request.url.includes('/api/assessment') && event.request.method === 'POST') {
    event.respondWith(
      event.request.json().then((data) => {
        // Store assessment data locally
        return caches.open(OFFLINE_CACHE).then((cache) => {
          const timestamp = new Date().toISOString();
          const assessmentData = { ...data, timestamp, id: Date.now() };
          
          return cache.put(`/assessment/${assessmentData.id}`, new Response(JSON.stringify(assessmentData), {
            headers: { 'Content-Type': 'application/json' }
          })).then(() => {
            return new Response(JSON.stringify({ success: true, id: assessmentData.id }), {
              status: 200,
              headers: { 'Content-Type': 'application/json' }
            });
          });
        });
      }).catch(() => {
        return new Response(JSON.stringify({ error: 'Failed to store assessment' }), {
          status: 500,
          headers: { 'Content-Type': 'application/json' }
        });
      })
    );
    return;
  }

  // Cache-first strategy for app shell
  if (event.request.destination === 'document' || 
      event.request.destination === 'script' || 
      event.request.destination === 'style' ||
      event.request.destination === 'image') {
    
    event.respondWith(
      caches.match(event.request)
        .then((response) => {
          if (response) {
            return response;
          }
          
          return fetch(event.request).then((response) => {
            // Cache successful responses
            if (response.status === 200) {
              const responseClone = response.clone();
              caches.open(CACHE_NAME).then((cache) => {
                cache.put(event.request, responseClone);
              });
            }
            return response;
          });
        })
        .catch(() => {
          // Return offline page for navigation requests
          if (event.request.destination === 'document') {
            return caches.match('/');
          }
        })
    );
  }
});

// Background sync for when connection is restored
self.addEventListener('sync', (event) => {
  console.log('Background sync triggered:', event.tag);
  
  if (event.tag === 'sync-assessments') {
    event.waitUntil(syncAssessments());
  }
});

// Sync stored assessments when online
async function syncAssessments() {
  try {
    const cache = await caches.open(OFFLINE_CACHE);
    const requests = await cache.keys();
    
    for (const request of requests) {
      if (request.url.includes('/assessment/')) {
        const response = await cache.match(request);
        const data = await response.json();
        
        // Attempt to sync with server
        try {
          await fetch('/api/sync-assessment', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
          });
          
          // Remove from cache after successful sync
          await cache.delete(request);
          console.log('Assessment synced and removed from cache:', data.id);
        } catch (error) {
          console.log('Failed to sync assessment:', data.id);
        }
      }
    }
  } catch (error) {
    console.error('Error syncing assessments:', error);
  }
}

// Message handling for manual sync triggers
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SYNC_ASSESSMENTS') {
    syncAssessments();
  }
  
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});